1-1、	31 41 59 26 41 58	41为key大于31，41放置在原位置；
		31 41 59 26 41 58	59为key大于41，59放置在原位置；
		31 41 59 26 41 58	26为key，j为26的位置，26小于59，59放置在j，26小于41，41放置在j-1,26小于31,31放置在j-2，最后将26放置在j-3。
		26 31 41 59 41 58	41为key，j为41的位置，41小于59,59放置在j，41放置在j-1.
		26 31 41 41 59 58	58为key，58小于59,59放置在j，58放置在j-1.
		26 31 41 41 58 59	得到排序结果
1-2、见1_2_insertion_sort.
1-3、见1_3_liner_find.
		循环不变式：所有下标小于i当前值的数都不是所求的下标值。
		初始化：该情况下i=1,下标最小，所以情况为真。
		保持：对于某次迭代，下标值为i，小于i的下标对应数组中的值与v都不想等，且if语句判断当前下标对应数组中的值A[i]与v的相等性，如果相等则程序返回下标值i，即所求的值，否则迭代继续执行，此时下标值比上次迭代下标值大1,且所有小于该下标值的数组中值都不与v相等。
		终止：当下标值大于数组长度时终止，此时所有小于该下标值的数组中对应位置的值都与v不相等，按要求置v=NIL。
1-4、	输入：两个代表二进制的序列A和B，其中A=<a1,a2,…,an>,B=<b1,b2,…,bn>，a1~an和b1~bn取值范围为{0,1}。
		输出：一个代表二进制的序列C，其中C=<c1,c2,…,cn,cn+1>,c1~cn+1取值范围为{0,1}。
	为代码见1_4_add.
2-2、见2_2_selection_sort.
		循环不变式：每次循环结束后将序列中第i小的元素放置在序列的第i个位置上
		因为循环不变式，算法只需要n-1次循环将前n-1小的元素按序放置在前n-1个位置上，于是自然有第n个位置放置的是第n小（即最大）的元素。
2-4、降低一个算法的高阶项的增长率。
3-1、做图过程略；
3-2、见3_2_merge.
3-3、已证明；
3-4、公式略；
3-5、见3_5_binary_search.
3-6、理论上可行，但没有合适的数据结构，在插入时需要移动插入位置之后的元素，如果使用数组则挪动元素还是需要与n线性相关的时间，如果使用链表则不能使用直接下标索引来进行二分查找，而遍历链表需要的也是n线性相关的时间。
3-7、设a+b=x,a和b都属于S，算法对于任意的a属于S，二分查找x-b。

思考题目
2-1、a.证明：插入排序的最高阶项出现在步骤5中，对于每个长度为k的子表，计算其所需时间的公式为k的平方级，然后以该值乘以n/k个子表得到在时间上的最高阶项即为nk。
	b.由于叶子节点总共有n/k个，每个叶子节点的合并时间与其长度相关，设为ck，则总层数求得为lg(n/k)+1，每层的处理时间都总和都为cn，得到乘积的和为cn*lg(n/k)+cn,所以最坏情况下合并子表的时间中最高阶项为n*lg(n/k)。
	c.k最大值为lgn。
	d.选择一个小于lgn且得到的子表个数为偶数的k值。
2-2、a.给定一个对于算法整体的循环不变式，证明其初始化时成立，且能够在每次迭代时保持其成立，最后能在终止时得到已排序的结果。
	b.循环不变式：序列A下标j位置的元素是子序列A[j...n]中最小的元素（之一）。
		初始化：j为A.length，表明该元素是序列A的最后一个元素，自然有循环不变式成立。
		保持：在一次迭代开始前，下标t1位置的元素是子序列A[t1...n]中最小的元素（之一），迭代开始时下标值j=t1,if语句比较j位置的元素与j-1位置元素的大小，将值较小的元素放在j-1位置（若相等则不交换）。所以在下次迭代开始前，下标t1-1位置的元素是子序列A[t1-1...n]中最小的元素（之一）。循环不变式得到保持。
		终止：在循环终止时，j的值为i+1,可以得到子序列A[i...n]中最小的元素（之一）在下标i的位置。
	c.循环不变式：子序列A[1...i]中的元素是按非递减序排列的
		初始化：i=1时，子序列只有唯一的元素，自然是按照非递减序排列的。
		保持：假设一次迭代开始i=k，子序列A[1...k]中的元素按照非递减序排列，进入内部循环，由内部循环的循环不变式的终止得到，此时对于子序列A[k...n]，最小的元素（之一）在下标k的位置上，其他位置的元素都不小于A[k]，所以当i=k+1时，子序列A[1..k+1]中的元素是按照非递减序排列的。
		终止：在循环终止时，i的值为n，可以得到子序列A[1...n]中的元素是按照非递减序排列的。
	d.n平方，更差
2-3、a.n
	b.利用两个for循环，外层for循环处理多项式系数乘法和求和运算，里层for循环处理x的乘方运算。时间复杂度为n平方，性能比霍钠规则要差得多。
	c.数学证明即可。
	d.由多项式P(x)的表达可知该代码片段能够正确的求出多项式的值。
2-4、a.(2,1) (3,1) (8,6) (8,1) (6,1).
	b.集合中的元素按照非递增序排列时具有最多的逆序对，逆序对的数量为(n2-n)/2.
	c.一般来说，有多少个逆序对，插入排序中就会产生多少次元素的移动。
	d.见伪代码think_reverse_pair和c代码reverse_pair.c.
		