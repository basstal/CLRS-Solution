# 中位数和顺序统计量

## 9.1-1

Q：证明：在最坏情况下，找到$n$个元素中第二小的元素需要$n+\lceil\lg n\rceil-2$次比较。（提示：可以同时找最小元素。）

A：

```code
FIND-SECOND-MINIMAL(A, n):
    min, min2 = COMPARE(A[1], A[2])
    for i = 3 to n step 2:
        m, m2 = COMPARE(A[i], A[i+1])
        new-min = COMPARE(m, min)
        if new-min == m:
            min2 = min
            min = m
            min2 = COMPARE(min2, m2)
        else
            min2 = COMPARE(min2, m)
    if i < n:
        new-min = COMPARE(min, A[n])
        if new-min == min
            min2 = COMPARE(min2, A[n])
        else
            min2 = min
```

该算法的比较次数，包括第一对元素，每对元素比较一次$\lceil\lg n\rceil$，除第一对元素外，循环中每对元素比较两次$n-2$，如果元素个数是奇数，则循环结束时循环次数比元素个数为偶数少1，因此总比较次数少于偶数次循环。因此最坏情况下，找到$n$个元素中第二小的元素需要$n+\lceil\lg n\rceil-2$次比较。

--------------------

## 9.1-2

Q：证明：在最坏情况下，同时找到$n$个元素中最大值和最小值的比较次数的下界是$\lceil3n/2\rceil-2$。（提示：考虑有多少个数有成为最大值或最小值的潜在可能，然后分析一下每一次比较会如何影响这些计数。）

A：在任意$n$个元素中同时找最大值和最小值，那么对于这$n$个元素而言，假设有$n/2$的元素是潜在最小值可能，则剩下$n/2$的元素是潜在最大值可能，则需要对潜在可能的元素遍历比较，总共$n-2$次比较。任意其他划分总的比较次数与该划分一样。要得到该划分，需要对$n$个元素两两比较，将较小的元素划分到潜在最小值可能，而较大的元素划分到潜在最大值可能，总共需要$n/2$次比较。任意其他划分的比较次数$>n/2$次比较。因此最坏情况下，同时找到$n$个元素中最大值和最小值的比较次数下界是$\lceil3n/2\rceil-2$。

--------------------

## 9.2-1

Q：证明：在RANDOMIZED-SELECT中，对长度为0的数组，不会进行递归调用。

A：长度为$0$，则$p=r=0$，函数会在一开始就返回。

--------------------

## 9.2-2

Q：请讨论：指示器随机变量$X_k$和$T(max(k-1, n-k))$是独立的。

A：我们从程序中知道，影响指示器随机变量$X_k$值的过程在第3行，即划分后得到主元位置q。而影响$T(max(k-1, n-k))$值的过程在8行和9行。它们的发生是没有相互关系的，不论第3行得到什么样的结果对执行8行或9行中过程的时间没有影响，因此这两个变量是独立的。

--------------------

## 9.2-3

Q：给出RANDOMIZED-SELECT的一个基于循环的版本。

A：

```code
RANDOMIZED-SELECT(A,p,r,i):
    if p == r
        return A[p]
    q = RANDOMIZE-PARTITION(A,p,r)
    k = q - p + 1
    while i != k
        if i < k
            q = RANDOMIZED-PARTITION(A,p,q-1)
        else
            p = q + 1
            q = RANDOMIZED-PARTITION(A,q+1,r)
        k = q - p + 1
```

--------------------

## 9.2-4

Q：假设用RANDOMIZED-SELECT去选择数组$A=<3, 2, 9, 0, 7, 5, 4, 8, 6, 1>$的最小元素，给出能够导致RANDOMIZED-SELECT最坏情况发生的一个划分序列。

A：从9到1，每个数都刚好依次被选中作为主元，得到的划分$q$依次为$<10, 9, 8, 7, 6, 5, 4, 3, 2>$。

--------------------

## 9.3-1

Q：在算法SELECT中，输入元素被分为每组5个元素。如果它们被分为每组7个元素，该算法仍然会是线性时间吗？证明：如果分成每组3个元素，SELECT的运行时间不是线性的。

A：由同样的方法推得，如果被分为每组7个元素，选择$n \gt 112$且$c\geq 14a$能够使算法仍然是线性的。然而被分成每组3个元素的情况下，算法运行时间不是线性的。

--------------------

## 9.3-2

Q：分析SELECT，并证明：如果$n\geq 140$，则至少$\lceil n/4 \rceil$个元素大于中位数的中位数$x$，至少$\lceil n/4 \rceil$个元素小于$x$？

A：由之前推导的大于$x$的元素个数至少为：$3n/10 - 6$

$3n/10 - 6 \geq \lceil n/4 \rceil$

$3n/10 -6 \geq n/4 + 1$

$n/20 \geq 7$

$n \geq 140$

--------------------

## 9.3-3

Q：假设你已经有了一个最坏情况下是线性时间的用于求解中位数的“黑箱”子程序。设计一个能在线性时间内解决任意统计量的选择问题算法。

先进行一次最坏情况下为$\Omicron(n)$时间复杂度的中位数选择，然后将改中位数作为快速排序的key。总的复杂度不超过$\Omicron(n\lg{n})$。

--------------------

## 9.3-4

