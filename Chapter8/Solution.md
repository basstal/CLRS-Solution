8.1-1   n-1

#8.1-2   

$$
    \sum_{k=1}^n{\log_2{k}} \leq \sum_{k=1}^n{\log_2{n}} = n\log_2{n} = \Omicron({n\log_2{n}})
$$

$$
    \sum_{k=1}^n{\log_2{k}} \geq \log_2{\sqrt{n}^n} = \frac{n}{2}\log_2{n} = \Omicron({n\log_2{n}})
$$

#8.1-3   $2^n$在渐进上远大于$\frac{n!}{2}$、$\frac{n!}{n}$、$\frac{n!}{2^n}$

#8.1-4   
$(k!)^{\frac{n}{k}} \leq 2^h$

$h \geq \log_2{(k!)^{\frac{n}{k}}}$

$h \geq \frac{n}{k} k \log_2{k}$

$h \geq n \log_2{k} = \Omega(n \log_2{k})$ 

8.2-1 略

8.2-2 从后往前，设任意两个相同数字，其在A中下标分别为number1、number2，有number1 > number2，由算法过程可知C[number1] > C[number2]，由此可推得排序后这两个相同数字保持相对位置不变。

8.2-3 不稳定;

由于总数据未发生改变，只是遍历方式发生改变，对每类不相同的数字number，其C[number]在B中所占的区间长度未发生改变。因此算法能保证每类number位于B中同样的下标段内，结果算法仍是正确的。

8.2-4

```
COUNTING-RANGE-COUNT(A, n, a, b)
    let C[0..k] be a new array    
    for i = 0 to k    
        C[i] = 0        
    for j = 1 to n    
        C[A[j]] = C[A[j]] + 1        
    for i = 1 to k    
        C[i] = C[i] + C[i - 1]
    return C[b] - C[a - 1]
```

8.3-1 略

8.3-2 稳定排序：归并、插入

可以把数据在原址中的下标数据带上，对数据进行排序后，对值相同的数据分别按照下标再排序一次；这种方法空间是原数据的两倍，时间比原排序时间要稍微多一些。

8.3-3 只有1列的情况，自然是正确的；

假设对于n列的情况是正确的，要证明对于n+1列是正确的：

由于排序算法是稳定的，对第n+1列的排序不会改变n+1列相同值的相对位置，也就是说第n+1列中任意两个相同的数，在余下的n列，已排序完成的结果先后顺序没有改变，因此这两个相同的数对于n+1列来说是正确的（有序的）。

#8.3-4 将这n个数看作n进制的数，则可以在3次大小为n的计数排序后得到排序结果。

8.3-5 d，$10 ^ d$

8.4-1 略

8.4-2 退化为插入排序因此复杂度为$n^2$，可以将排序算法改为归并排序或快速排序

8.4-3 

$$
    E[x^2] = \frac{1}{2} \times 1^2 + (1 - \frac{1}{2}) \times 0 ^ 2 = \frac{1}{2}
$$

$$
    E^2[X] = (\frac{1}{2} \times 1 + (1 - \frac{1}{2}) \times 0) ^ 2 = \frac{1}{4}
$$

#8.4-4

使每个圆环（园）的面积相同，则桶大小相同

#8.4-5

共有n个数字，bucket的划分点$i_1$,$i_2$...$i_n$为P($i_1$) = $\frac{1}{n}$ , p($i_2$) = $\frac{2}{n}$, ..., P($i_n$) = $\frac{(n-1)}{n}$. 因为找出这些划分点需要n*O(1) = O(n)的时间，桶排序也是O(n)的，所以最终是O(n)的。